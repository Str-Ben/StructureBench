// Lark grammar converted from ANTLR v3 PDDL grammar (Pddl.g)

start: pddl_doc

pddl_doc: (domain | problem)

// -------- DOMAINS --------

domain: LP DEFINE WS? domain_name WS? require_def? WS? types_def? WS? constants_def? WS? predicates_def? WS? functions_def? WS? constraints? WS? structure_def* WS? RP

domain_name: LP DOMAIN_KW WS? NAME WS? RP

require_def: LP REQUIREMENTS WS? REQUIRE_KEY+ WS? RP

types_def: LP TYPES WS? typed_name_list WS? RP

// If have any typed names, they must come FIRST!
typed_name_list: (NAME (WS? NAME)*) | (single_type_name_list (WS? single_type_name_list)* (WS? NAME)*)

single_type_name_list: NAME (WS? NAME)* WS? HYPHEN WS? type_

type_: (LP EITHER WS? prim_type (WS? prim_type)+ WS? RP) | prim_type

prim_type: NAME

functions_def: LP FUNCTIONS WS? function_list WS? RP

function_list: (atomic_function_skeleton (WS? atomic_function_skeleton)* (WS? HYPHEN WS? function_type)?)?

atomic_function_skeleton: LP function_symbol WS? typed_variable_list WS? RP

function_symbol: NAME

function_type: NUMBER_T

// Currently in PDDL only numeric functions are allowed
constants_def: LP CONSTANTS WS? typed_name_list WS? RP

predicates_def: LP PREDICATES WS? atomic_formula_skeleton (WS? atomic_formula_skeleton)* WS? RP

atomic_formula_skeleton: LP predicate WS? typed_variable_list WS? RP

predicate: NAME

// If have any typed variables, they must come FIRST!
typed_variable_list: (VARIABLE (WS? VARIABLE)*) | (single_type_var_list (WS? single_type_var_list)* (WS? VARIABLE)*)

single_type_var_list: VARIABLE (WS? VARIABLE)* WS? HYPHEN WS? type_

constraints: LP CONSTRAINTS WS? con_gd WS? RP

structure_def: action_def | durative_action_def | derived_def

// -------- ACTIONS --------

action_def: LP ACTION WS? action_symbol WS? PARAMETERS WS? LP WS? typed_variable_list WS? RP WS? action_def_body WS? RP

action_symbol: NAME

action_def_body: (PRECONDITION WS? (empty_parens | goal_desc))? (WS? EFFECT WS? (empty_parens | effect))?

empty_parens: LP WS? RP

goal_desc: atomic_term_formula
        | LP AND WS? goal_desc_list? WS? RP
        | LP OR WS? goal_desc_list? WS? RP
        | LP NOT WS? goal_desc WS? RP
        | LP IMPLY WS? goal_desc WS? goal_desc WS? RP
        | LP EXISTS WS? LP WS? typed_variable_list WS? RP WS? goal_desc WS? RP
        | LP FORALL WS? LP WS? typed_variable_list WS? RP WS? goal_desc WS? RP
        | f_comp

goal_desc_list: goal_desc (WS? goal_desc)*

f_comp: LP binary_comp WS? f_exp WS? f_exp WS? RP

atomic_term_formula: LP predicate (WS? term)* WS? RP

term: NAME | VARIABLE

// -------- DURATIVE ACTIONS --------

durative_action_def: LP DURATIVE_ACTION WS? action_symbol WS? PARAMETERS WS? LP WS? typed_variable_list WS? RP WS? da_def_body WS? RP

da_def_body: (DURATION WS? duration_constraint)
          | (CONDITION WS? (empty_parens | da_gd))
          | (EFFECT WS? (empty_parens | da_effect))

// Note: ANTLR uses daGD: prefTimedGD | (and ...) | (forall ...)
da_gd: pref_timed_gd
    | LP AND WS? da_gd_list? WS? RP
    | LP FORALL WS? LP WS? typed_variable_list WS? RP WS? da_gd WS? RP

da_gd_list: da_gd (WS? da_gd)*

pref_timed_gd: timed_gd | LP PREFERENCE (WS? NAME)? WS? timed_gd WS? RP

timed_gd: LP AT WS? time_specifier WS? goal_desc WS? RP
        | LP OVER WS? interval WS? goal_desc WS? RP

time_specifier: START | END

interval: ALL

// -------- DERIVED --------

derived_def: LP DERIVED WS? typed_variable_list WS? goal_desc WS? RP

// -------- EXPRESSIONS --------

f_exp: NUMBER
    | LP binary_op WS? f_exp WS? f_exp2 WS? RP
    | LP MINUS WS? f_exp WS? RP
    | f_head

f_exp2: f_exp

f_head: LP function_symbol (WS? term)* WS? RP | function_symbol

effect: LP AND WS? c_effect_list? WS? RP | c_effect

c_effect_list: c_effect (WS? c_effect)*

c_effect: LP FORALL WS? LP WS? typed_variable_list WS? RP WS? effect WS? RP
      | LP WHEN WS? goal_desc WS? cond_effect WS? RP
      | p_effect

p_effect: LP assign_op WS? f_head WS? f_exp WS? RP
      | LP NOT WS? atomic_term_formula WS? RP
      | atomic_term_formula

cond_effect: LP AND WS? p_effect_list? WS? RP | p_effect

p_effect_list: p_effect (WS? p_effect)*

binary_op: STAR | PLUS | MINUS | SLASH

binary_comp: GT | LT | EQ | GE | LE

assign_op: ASSIGN | SCALE_UP | SCALE_DOWN | INCREASE | DECREASE

// -------- DURATIONS --------

duration_constraint: LP AND WS? simple_duration_constraint (WS? simple_duration_constraint)+ WS? RP
                   | empty_parens
                   | simple_duration_constraint

simple_duration_constraint: LP dur_op WS? DURATION_VAR WS? dur_value WS? RP
                         | LP AT WS? time_specifier WS? simple_duration_constraint WS? RP

dur_op: LE | GE | EQ

dur_value: NUMBER | f_exp

da_effect: LP AND WS? da_effect_list? WS? RP
         | timed_effect
         | LP FORALL WS? LP WS? typed_variable_list WS? RP WS? da_effect WS? RP
         | LP WHEN WS? da_gd WS? timed_effect WS? RP
         | LP assign_op WS? f_head WS? f_exp_da WS? RP

da_effect_list: da_effect (WS? da_effect)*

timed_effect: LP AT WS? time_specifier WS? da_effect WS? RP
            | LP AT WS? time_specifier WS? f_assign_da WS? RP
            | LP assign_op WS? f_head WS? f_exp WS? RP

f_assign_da: LP assign_op WS? f_head WS? f_exp_da WS? RP

f_exp_da: LP WS? ((binary_op WS? f_exp_da WS? f_exp_da) | (MINUS WS? f_exp_da)) WS? RP
        | DURATION_VAR
        | f_exp

// -------- PROBLEMS --------

problem: LP DEFINE WS? problem_decl WS? problem_domain WS? require_def? WS? object_decl? WS? init_ WS? goal WS? prob_constraints? WS? metric_spec? WS? RP

problem_decl: LP PROBLEM_KW WS? NAME WS? RP

problem_domain: LP DOMAIN_DECL WS? NAME WS? RP

object_decl: LP OBJECTS WS? typed_name_list WS? RP

init_: LP INIT WS? init_el* WS? RP

init_el: name_literal
       | LP EQ WS? f_head WS? NUMBER WS? RP
       | LP AT WS? NUMBER WS? name_literal WS? RP

name_literal: atomic_name_formula
            | LP NOT WS? atomic_name_formula WS? RP

atomic_name_formula: LP predicate (WS? NAME)* WS? RP

goal: LP GOAL WS? goal_desc WS? RP

prob_constraints: LP CONSTRAINTS WS? pref_con_gd WS? RP

pref_con_gd: LP AND WS? pref_con_gd* WS? RP
           | LP FORALL WS? LP WS? typed_variable_list WS? RP WS? pref_con_gd WS? RP
           | LP PREFERENCE (WS? NAME)? WS? con_gd WS? RP
           | con_gd

metric_spec: LP METRIC WS? optimization WS? metric_f_exp WS? RP

optimization: MINIMIZE | MAXIMIZE

metric_f_exp: LP binary_op WS? metric_f_exp WS? metric_f_exp WS? RP
            | LP (STAR | SLASH) WS? metric_f_exp WS? metric_f_exp+ WS? RP
            | LP MINUS WS? metric_f_exp WS? RP
            | NUMBER
            | LP function_symbol (WS? NAME)* WS? RP
            | function_symbol
            | TOTAL_TIME
            | LP IS_VIOLATED WS? NAME WS? RP

// -------- CONSTRAINTS (con_gd) --------

con_gd: LP AND WS? con_gd* WS? RP
     | LP FORALL WS? LP WS? typed_variable_list WS? RP WS? con_gd WS? RP
     | LP AT WS? END WS? goal_desc WS? RP
     | LP ALWAYS WS? goal_desc WS? RP
     | LP SOMETIME WS? goal_desc WS? RP
     | LP WITHIN WS? NUMBER WS? goal_desc WS? RP
     | LP AT_MOST_ONCE WS? goal_desc WS? RP
     | LP SOMETIME_AFTER WS? goal_desc WS? goal_desc WS? RP
     | LP SOMETIME_BEFORE WS? goal_desc WS? goal_desc WS? RP
     | LP ALWAYS_WITHIN WS? NUMBER WS? goal_desc WS? goal_desc WS? RP
     | LP HOLD_DURING WS? NUMBER WS? NUMBER WS? goal_desc WS? RP
     | LP HOLD_AFTER WS? NUMBER WS? goal_desc WS? RP

// ========== Terminals ==========
LP: "("
RP: ")"
HYPHEN: "-"

DEFINE: "define"
DOMAIN_KW: "domain"
REQUIREMENTS: ":requirements"
TYPES: ":types"
CONSTANTS: ":constants"
PREDICATES: ":predicates"
FUNCTIONS: ":functions"
CONSTRAINTS: ":constraints"

ACTION: ":action"
DURATIVE_ACTION: ":durative-action"
DERIVED: ":derived"
PARAMETERS: ":parameters"
PRECONDITION: ":precondition"
EFFECT: ":effect"
DURATION: ":duration"
CONDITION: ":condition"

AND: "and"
OR: "or"
NOT: "not"
IMPLY: "imply"
EXISTS: "exists"
FORALL: "forall"
WHEN: "when"
AT: "at"
OVER: "over"

START: "start"
END: "end"
ALL: "all"

ALWAYS: "always"
SOMETIME: "sometime"
WITHIN: "within"
AT_MOST_ONCE: "at-most-once"
SOMETIME_AFTER: "sometime-after"
SOMETIME_BEFORE: "sometime-before"
ALWAYS_WITHIN: "always-within"
HOLD_DURING: "hold-during"
HOLD_AFTER: "hold-after"

PREFERENCE: "preference"
EITHER: "either"
NUMBER_T: "number"

ASSIGN: "assign"
SCALE_UP: "scale-up"
SCALE_DOWN: "scale-down"
INCREASE: "increase"
DECREASE: "decrease"

DURATION_VAR: "?duration"

STAR: "*"
PLUS: "+"
MINUS: "-"
SLASH: "/"

GT: ">"
LT: "<"
EQ: "="
GE: ">="
LE: "<="

PROBLEM_KW: "problem"
DOMAIN_DECL: ":domain"
OBJECTS: ":objects"
INIT: ":init"
GOAL: ":goal"
METRIC: ":metric"
MINIMIZE: "minimize"
MAXIMIZE: "maximize"
TOTAL_TIME: "total-time"
IS_VIOLATED: "is-violated"

REQUIRE_KEY: /:(strips|typing|negative-preconditions|disjunctive-preconditions|equality|existential-preconditions|universal-preconditions|quantified-preconditions|conditional-effects|fluents|adl|durative-actions|derived-predicates|timed-initial-literals|preferences|constraints)/

NAME: /[A-Za-z][A-Za-z0-9_-]*/
VARIABLE: /\?[A-Za-z][A-Za-z0-9_-]*/
NUMBER: /[0-9]+(\.[0-9]+)?/

WS: (" "|"\t"|"\n"|"\r")+

%import common.WS_INLINE
%import common.NEWLINE
%ignore WS
